# 云通讯介绍
1. 先注册
2. 然后稍微看一下模板.
3. 然后去SDK下载一个东东!demo.测试压缩包
    https://www.yuntongxun.com/doc/ready/demo/1_4_1_2.html
4. 然后,我们想发短信的时候,调用一下函数就可以了.
    1. 但是,好像有个但是,看看什么情况.!
    2. 但是在调用send_template,已经持续在跟云通讯通信了.
    3. 先拿到凭据,然后再进行通信.
    4. ## 然后每次都调用上面的代码,重复去调用,会有延迟,所以可以自定义一个类.!
5. 然后把一些不应该重复的代码,就封装在类里面,但是又必须第一时间运行,就放到__init__里面就可以了.
    1. 但是,注意了,如果这些代码需要被调用的话,还得设置赋值给self,不然的话,不好共享啊~.不设置就变成局部变量了.!
6. 然后还可以设置一个单例模式.
    1. 忘记返回的是调用父类的new方法.
    2. 除非是第一次实例化,返回父类的new方法,否则,都是返回已经实例化过的单类.
        1. 这个例子里面,学到了,就是如果都是返回同一个类型的数值,判断条件又只有两个,就可以这样了,挺灵活的.!
        ```python
        def __new__(cls):
        if cls.tag !=None:
            return super().__new__(cls)
        return cls.tag
        ```
    3. ## 对,如果该文件不是被调用,如果这个文件,作为单独运行的,或者入口的话,都得设置 if __name__ = "__main__"来运行,
    这是一个好习惯.!
    4. 这...传智介绍的短信.....太烂了....都是基于python2的....意思是,我得精通python3..太好了.当做练习.!
7. python3里面,不建议使用urllib了.
8. python3里面,字典取消了iteritems(),直接被items()取缔了.!

# 路由url地址转化原来就叫过滤器.

1. 这是是关于简书的一遍文章,说的就是转换器.
    https://www.jianshu.com/p/ce3028e9546e
2. ## 在flask中使用jsonify和json.dumps的区别
    https://blog.csdn.net/Duke_Huan_of_Qi/article/details/76064225
    1. 所以说,在flask中的话,就尽量多用jsonify.
3. ## 获取get过来的参数
    1. 写法是 xx = request.args.get("xxx")
    2. 然后使用if not all(['xx','yy'])
    3. 然后我观察了一下路由和函数的关系
    ```python
    @api.route("/sms_codes/<re(r'1[34578]\d{9}'):mobile>")
    def get_sms_code(mobile):
    ```
    > 恩恩,顾名思义
4. ## 看一下flask操作数据库先!
    1. ### 从redis获取str类型数据
    ```python
        redis_store.get('xxx')
    ```
    2. ### 如果发生错误,调用当前的 currect_app.logger.error(e)
    3. 记得经常返回json数据的话,用 return jsonify
    4. ### 获取模型类的数据
    ```python
    from models import xxx
    User.query.filter_by(mobile=mobile).first()
    ```
    5. 如果查询手机号码异常的话,就继续往下走.暂时不管了.!
    6. 生成手机验证码>!
        1. 生成随机数.使用random,---> sms_code = "%06d" % random.randint(0, 999999)
        2. ### 字符串格式符."%06",注意了,6前面的0,意思是,这是一个固定的6位数,如果这个整数不足6位数的话,就自动补充0.
        3. ### 保存真实验证码内容
            1. 也是使用setex
5. 为什么,不用一个大的try来去捕获所有的错误?而这么麻烦去一个一个去写.!
    1. except不能判断具体那一块出问题.
    2. 在try中间的代码块还是越少越好,不然有时候可能会影响效率.!

6. ## 稍稍总结一下后台验证码的流程.
    - ### 强调一下,在python3里面麻烦就下载一下pip install captcha
    1. 首先调用另外一个生成验证码的模块
        1. 然后返回正式验证码,还有图片验证码
            1. 说说细节,上面的模块调用会返回三个返回值
                第一是:name,唯一值
                第二是:真实验证码的字符串
                第三是:图片流
            2. ### 真实验证码就必须存到数据库,保存到redis数据库中.!
            3. ### 图片验证码图片流就放到make_response(xx)里面.
                1. #### 然后函数里面调用PIL的image,然后创建一个空白的,
                    out = Bytes()
                    然后image.save = (out,format='JPEG')
            4. ### 记得啊,这些视图处理函数都得返回信息啊!.返回图片流,而且是header-->Content-Type=image/jpeg
                返回image.get_value()的的图片流
        2. ### 然后某些容易出错部分,可以设置日志记录
    2. 发送短信验证码
        1. 生成随机的验证码.
            1. 先生成UUID号码.然后绑定随机的验证码
            2. 把真实值保存到redis中!
        2. 调用短信API发送
            1. 从数据库中获取图形验证码的真实值,然后保存到当前bianliang
                1. 然后删除redis当中保存的验证码,防止多次验证.>((???为了防止爬虫?))
            2. 得用正则判断一下手机号码的有效性吧.
                1. 然后就对比图形化验证码的有效性.
                2. ### 然后,判断一下手机是否60秒过于频繁.
                    1. 如果是就返回!
            3. 判断手机号码是否存在??????/
                1. 什么意思?
                2. 看到了,是去User数据库里面找到,目标就看看这个用户是否注册过!.
            3. 如果都正确就可以发送了.!

# 修改前端,用来发送手机短信验证码
1. 如果点击了发送验证码之后,可以使用remoteAttr,去移除点击按钮.!暂时性的.等下重新添加属性.!
2. 

# 校验步骤
1. 接收数据
2. 校验数据
3. 业务处理
4. 返回数据